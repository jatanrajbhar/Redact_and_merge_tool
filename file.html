<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redaction & Merger Tool - PDF Redaction Tool</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- PDF.js for text extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <!-- pdf-lib for PDF manipulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        border: "hsl(214.3 31.8% 91.4%)",
                        input: "hsl(214.3 31.8% 91.4%)",
                        ring: "hsl(222.2 84% 4.9%)",
                        background: "hsl(0 0% 100%)",
                        foreground: "hsl(222.2 84% 4.9%)",
                        primary: { DEFAULT: "hsl(222.2 47.4% 11.2%)", foreground: "hsl(210 40% 98%)" },
                        secondary: { DEFAULT: "hsl(210 40% 96.1%)", foreground: "hsl(222.2 47.4% 11.2%)" },
                        muted: { DEFAULT: "hsl(210 40% 96.1%)", foreground: "hsl(215.4 16.3% 46.9%)" },
                    }
                }
            }
        }
    </script>

    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        .spinner { border: 3px solid #e2e8f0; border-top: 3px solid #3b82f6; border-radius: 50%; width: 20px; height: 20px; animation: spin 0.8s linear infinite; display: inline-block; vertical-align: middle; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 min-h-screen flex flex-col">

    <div id="app" class="flex-grow flex flex-col"></div>

    <script>
        // Initialize PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // --- STATE ---
        const state = {
            files: [],       // { id, file, name, size, pageCount, arrayBuffer, textByPage: [{text, items:[{str,x,y,width,height,pageHeight,pageWidth}]}] }
            rules: [
                { id: "name", name: "Name (Title Case)", pattern: "[A-Z][a-z]+(?:\\s[A-Z][a-z]+){1,4}", enabled: true, color: "#ef4444" },
                { id: "trade", name: "Trade Name", pattern: "[A-Z][A-Z\\s&.,]+(?:PRIVATE\\s+LIMITED|PVT\\.?\\s*LTD\\.?|LTD\\.?|LLP|INC\\.?|ENTERPRISES?|TRADERS?|INDUSTRIES|SOLUTIONS|SERVICES|CORPORATION|ASSOCIATES|CONSULTANTS|COMPANY|CO\\.?|INTERNATIONAL|GLOBAL|GROUP|AGENCY|EXPORTS?|IMPORTS?)", enabled: true, color: "#f59e0b" },
                { id: "gstin", name: "GSTIN", pattern: "\\d{2}[A-Z]{5}\\d{4}[A-Z][A-Z\\d]Z[A-Z\\d]", enabled: true, color: "#10b981" },
                { id: "arn", name: "ARN", pattern: "(?<=ARN[:\\s-]?)[A-Z]{2}\\d{10,14}[A-Z\\d]", enabled: true, color: "#8b5cf6" },
                { id: "ip", name: "IP Address", pattern: "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}", enabled: true, color: "#f43f5e" },
                { id: "auth_signatory", name: "Authorized Signatory", pattern: "", enabled: true, color: "#ec4899", labelBased: true, labels: ["Name of Authorized Signatory", "Authorized Signatory", "Name of the Authorized"] },
                { id: "trade_label", name: "Trade Name (Label)", pattern: "", enabled: true, color: "#f97316", labelBased: true, labels: ["Trade name", "Legal name of the registered person", "Legal Name of Business", "Legal Name"] },
                { id: "arn_label", name: "ARN (Label)", pattern: "", enabled: true, color: "#7c3aed", labelBased: true, labels: ["ARN"] },
            ],
            matches: [],
            areas: [],
            isProcessing: false,
            isScanning: false,
            options: {
                removeMetadata: true,
                compress: false,
                mergeAll: true,
            }
        };

        // --- ICONS ---
        const icons = {
            shield: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>`,
            fileText: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><line x1="10" y1="9" x2="8" y2="9"/></svg>`,
            settings: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>`,
            download: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>`,
            trash: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>`,
            upload: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>`,
            check: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>`,
            x: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`,
        };

        // --- UTILS ---
        const formatFileSize = (bytes) => {
            if (bytes === 0) return "0 Bytes";
            const k = 1024;
            const sizes = ["Bytes", "KB", "MB", "GB"];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + " " + sizes[i];
        };

        const generateId = () => Math.random().toString(36).substring(2, 9);

        const validatePDF = (file) => file.type === "application/pdf" || file.name.endsWith(".pdf");

        // --- PDF TEXT EXTRACTION using PDF.js ---
        async function extractTextFromPDF(arrayBuffer) {
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const pageCount = pdf.numPages;
            const textByPage = [];

            for (let pageNum = 1; pageNum <= pageCount; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const viewport = page.getViewport({ scale: 1.0 });
                const textContent = await page.getTextContent();

                const items = textContent.items.map(item => {
                    const tx = item.transform;
                    return {
                        str: item.str,
                        x: tx[4],
                        y: tx[5],
                        width: item.width,
                        height: item.height || Math.abs(tx[3]) || 12,
                        pageWidth: viewport.width,
                        pageHeight: viewport.height,
                        fontName: item.fontName || '',
                    };
                });

                const fullText = textContent.items.map(item => item.str).join(' ');
                textByPage.push({ text: fullText, items, pageWidth: viewport.width, pageHeight: viewport.height });
            }

            return { pageCount, textByPage };
        }

        // --- REAL REGEX SCANNING ---
        function scanForRedactions() {
            const matches = [];
            const areas = [];

            state.files.forEach(file => {
                if (!file.textByPage) return;

                file.textByPage.forEach((pageData, pageIndex) => {
                    state.rules.forEach(rule => {
                        if (!rule.enabled) return;

                        try {
                            if (rule.labelBased) {
                                // Label-based matching: find text items after a label
                                scanLabelBasedMatches(pageData, rule, file.id, pageIndex, matches, areas);
                            } else if (rule.pattern) {
                                const regex = new RegExp(rule.pattern, 'g');
                                let match;

                                while ((match = regex.exec(pageData.text)) !== null) {
                                    const matchedText = match[0];
                                    const matchId = generateId();

                                    matches.push({
                                        id: matchId,
                                        ruleId: rule.id,
                                        ruleName: rule.name,
                                        text: matchedText,
                                        fileId: file.id,
                                        pageIndex: pageIndex,
                                        color: rule.color,
                                    });

                                    // Find the text items that correspond to this match
                                    const matchAreas = findTextItemsForMatch(pageData, matchedText, match.index);
                                    matchAreas.forEach(area => {
                                        areas.push({
                                            id: generateId(),
                                            matchId: matchId,
                                            fileId: file.id,
                                            pageIndex: pageIndex,
                                            x: (area.x / pageData.pageWidth) * 100,
                                            y: ((pageData.pageHeight - area.y - area.height) / pageData.pageHeight) * 100,
                                            width: (area.width / pageData.pageWidth) * 100,
                                            height: (area.height / pageData.pageHeight) * 100,
                                            absX: area.x,
                                            absY: area.y,
                                            absWidth: area.width,
                                            absHeight: area.height,
                                            color: rule.color,
                                        });
                                    });
                                }
                            }
                        } catch (e) {
                            console.warn(`Invalid regex pattern for rule "${rule.name}":`, e.message);
                        }
                    });
                });
            });

            state.matches = matches;
            state.areas = areas;
        }

        // Label-based scanning: finds a label in text items, then redacts the value items next to / after it
        function scanLabelBasedMatches(pageData, rule, fileId, pageIndex, matches, areas) {
            const items = pageData.items;
            if (!rule.labels || rule.labels.length === 0) return;

            for (const label of rule.labels) {
                const labelLower = label.toLowerCase();

                // Search through text items for the label
                for (let i = 0; i < items.length; i++) {
                    const itemText = items[i].str.trim().toLowerCase();

                    // Check if this item (or a sequence of items) contains the label
                    let labelFound = false;
                    let labelEndIndex = i;

                    // Try matching the label across consecutive items
                    let accumulated = '';
                    for (let j = i; j < Math.min(i + 8, items.length); j++) {
                        accumulated += (accumulated ? ' ' : '') + items[j].str.trim();
                        // Normalize whitespace for comparison (collapse multiple spaces)
                        const normalizedAccum = accumulated.toLowerCase().replace(/\s+/g, ' ');
                        const normalizedLabel = labelLower.replace(/\s+/g, ' ');
                        if (normalizedAccum.includes(normalizedLabel)) {
                            labelFound = true;
                            labelEndIndex = j;
                            break;
                        }
                    }

                    if (!labelFound) continue;

                    // Found the label - now find the value items after it
                    // Look for items that are to the right of or below the label
                    const labelItem = items[labelEndIndex];
                    const labelY = labelItem.y;
                    const labelRight = labelItem.x + (labelItem.width || 0);

                    // Collect value items: items on the same line to the right, or next line
                    const valueItems = [];
                    const heightTolerance = (labelItem.height || 14) * 4;
                    for (let j = labelEndIndex + 1; j < Math.min(labelEndIndex + 15, items.length); j++) {
                        const candidate = items[j];
                        if (!candidate.str.trim()) continue;

                        // Skip if it looks like another label (contains colon or common label words)
                        const candidateText = candidate.str.trim();
                        if (candidateText === ':' || candidateText === '-') continue;

                        // Check if on the same line (within height tolerance) or nearby lines
                        const sameLineOrNear = Math.abs(candidate.y - labelY) < heightTolerance;

                        if (sameLineOrNear) {
                            // Skip if this looks like a label keyword for another field
                            // Note: "name" is excluded from this list because the Authorized Signatory label contains "Name"
                            // and nearby items may also contain "Name" as part of the form structure
                            const looksLikeLabel = /^(trade\s*name|legal\s*name|gstin|arn|address|state\s*(name|code|jurisdiction)|date|type\s*of|status|constitution|jurisdiction)/i.test(candidateText);
                            if (looksLikeLabel && candidateText.length > 3) break;

                            valueItems.push(candidate);
                        } else {
                            break; // moved too far away
                        }
                    }

                    if (valueItems.length === 0) continue;

                    const valueText = valueItems.map(v => v.str.trim()).filter(Boolean).join(' ');
                    if (!valueText || valueText.length < 2) continue;

                    const matchId = generateId();
                    matches.push({
                        id: matchId,
                        ruleId: rule.id,
                        ruleName: rule.name,
                        text: valueText,
                        fileId: fileId,
                        pageIndex: pageIndex,
                        color: rule.color,
                    });

                    // Create redaction areas for each value item
                    valueItems.forEach(vItem => {
                        if (!vItem.str.trim()) return;
                        const area = {
                            x: Math.max(0, vItem.x - 2),
                            y: vItem.y - 2,
                            width: (vItem.width || vItem.str.length * 6) + 4,
                            height: (vItem.height || 14) + 4,
                        };

                        areas.push({
                            id: generateId(),
                            matchId: matchId,
                            fileId: fileId,
                            pageIndex: pageIndex,
                            x: (area.x / pageData.pageWidth) * 100,
                            y: ((pageData.pageHeight - area.y - area.height) / pageData.pageHeight) * 100,
                            width: (area.width / pageData.pageWidth) * 100,
                            height: (area.height / pageData.pageHeight) * 100,
                            absX: area.x,
                            absY: area.y,
                            absWidth: area.width,
                            absHeight: area.height,
                            color: rule.color,
                        });
                    });

                    // Skip ahead past the matched items to avoid duplicate matches
                    i = labelEndIndex + valueItems.length;
                }
            }
        }

        // Find text items that overlap with a regex match in the concatenated text
        function findTextItemsForMatch(pageData, matchedText, matchStartIndex) {
            const items = pageData.items;
            const results = [];

            // Build a map of character positions to text items
            let charIndex = 0;
            const charToItem = [];

            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                for (let c = 0; c < item.str.length; c++) {
                    charToItem.push(i);
                }
                // Account for the space separator we added between items
                charToItem.push(-1); // space between items
                charIndex += item.str.length + 1;
            }

            // Find which text items are covered by the match
            const coveredItemIndices = new Set();
            for (let i = matchStartIndex; i < matchStartIndex + matchedText.length && i < charToItem.length; i++) {
                if (charToItem[i] >= 0) {
                    coveredItemIndices.add(charToItem[i]);
                }
            }

            // Group consecutive items into rectangles
            const sortedIndices = [...coveredItemIndices].sort((a, b) => a - b);

            if (sortedIndices.length === 0) {
                // Fallback: create an approximate area
                return [{
                    x: pageData.pageWidth * 0.1,
                    y: pageData.pageHeight * 0.5,
                    width: matchedText.length * 6,
                    height: 14,
                }];
            }

            // Merge items that are on the same line (similar y coordinate)
            let currentGroup = null;
            sortedIndices.forEach(idx => {
                const item = items[idx];
                if (!item || !item.str.trim()) return;

                if (currentGroup && Math.abs(item.y - currentGroup.y) < item.height) {
                    // Same line, extend the group
                    const rightEdge = Math.max(currentGroup.x + currentGroup.width, item.x + item.width);
                    currentGroup.width = rightEdge - currentGroup.x;
                } else {
                    // New line
                    if (currentGroup) results.push(currentGroup);
                    currentGroup = {
                        x: item.x,
                        y: item.y,
                        width: item.width || matchedText.length * 5,
                        height: item.height || 14,
                    };
                }
            });
            if (currentGroup) results.push(currentGroup);

            // Add padding to redaction areas
            return results.map(r => ({
                x: Math.max(0, r.x - 2),
                y: r.y - 2,
                width: r.width + 4,
                height: r.height + 4,
            }));
        }

        // --- FILE HANDLING ---
        async function handleFilesAdded(newFiles) {
            const validFiles = Array.from(newFiles).filter(validatePDF);
            if (validFiles.length === 0) return;

            state.isScanning = true;
            render();

            for (const file of validFiles) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const { pageCount, textByPage } = await extractTextFromPDF(arrayBuffer.slice(0));

                    state.files.push({
                        id: generateId(),
                        file,
                        name: file.name,
                        size: file.size,
                        pageCount,
                        arrayBuffer,
                        textByPage,
                    });
                } catch (err) {
                    console.error(`Error processing ${file.name}:`, err);
                    alert(`Error processing ${file.name}: ${err.message}`);
                }
            }

            scanForRedactions();
            state.isScanning = false;
            render();
        }

        // --- ACTUAL PDF REDACTION & MERGING using pdf-lib ---
        async function handleDownload() {
            if (state.files.length === 0) return;

            state.isProcessing = true;
            render();

            try {
                const { PDFDocument, rgb, StandardFonts } = PDFLib;
                let outputPdf;

                if (state.options.mergeAll && state.files.length > 1) {
                    // Merge all PDFs into one
                    outputPdf = await PDFDocument.create();

                    for (const fileData of state.files) {
                        const sourcePdf = await PDFDocument.load(fileData.arrayBuffer.slice(0));
                        const copiedPages = await outputPdf.copyPages(sourcePdf, sourcePdf.getPageIndices());
                        copiedPages.forEach(page => outputPdf.addPage(page));
                    }
                } else {
                    // Just process the first file (or each individually)
                    outputPdf = await PDFDocument.load(state.files[0].arrayBuffer.slice(0));
                }

                // Apply redactions - draw black rectangles over matched text
                const pages = outputPdf.getPages();

                // Build a map of page indices per file for merged PDF
                let globalPageIndex = 0;
                const filePageMap = [];
                state.files.forEach(f => {
                    filePageMap.push({ fileId: f.id, startPage: globalPageIndex, pageCount: f.pageCount });
                    globalPageIndex += f.pageCount;
                });

                state.areas.forEach(area => {
                    let targetPageIndex;

                    if (state.options.mergeAll && state.files.length > 1) {
                        // Find the global page index in the merged document
                        const fileMapping = filePageMap.find(m => m.fileId === area.fileId);
                        if (!fileMapping) return;
                        targetPageIndex = fileMapping.startPage + area.pageIndex;
                    } else {
                        // Single file mode - only redact areas from the first file
                        if (area.fileId !== state.files[0].id) return;
                        targetPageIndex = area.pageIndex;
                    }

                    if (targetPageIndex >= 0 && targetPageIndex < pages.length) {
                        const page = pages[targetPageIndex];
                        const { width: pageWidth, height: pageHeight } = page.getSize();

                        // Use absolute coordinates stored from text extraction
                        const rectX = area.absX;
                        const rectY = area.absY;
                        const rectW = area.absWidth;
                        const rectH = area.absHeight;

                        // Draw black rectangle to cover the text
                        page.drawRectangle({
                            x: rectX,
                            y: rectY,
                            width: rectW,
                            height: rectH,
                            color: rgb(0, 0, 0),
                        });
                    }
                });

                // Remove metadata if option is enabled
                if (state.options.removeMetadata) {
                    outputPdf.setTitle('');
                    outputPdf.setAuthor('');
                    outputPdf.setSubject('');
                    outputPdf.setKeywords([]);
                    outputPdf.setProducer('AI Batch Stars - Redacted');
                    outputPdf.setCreator('AI Batch Stars');
                }

                // Save the PDF
                const pdfBytes = await outputPdf.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;

                if (state.options.mergeAll && state.files.length > 1) {
                    link.download = `merged_redacted_${state.files.length}_files.pdf`;
                } else {
                    link.download = `redacted_${state.files[0].name}`;
                }

                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

            } catch (err) {
                console.error('Error processing PDF:', err);
                alert(`Error processing PDF: ${err.message}`);
            }

            state.isProcessing = false;
            render();
        }

        // --- STATE ACTIONS ---
        function toggleRule(id) {
            state.rules = state.rules.map(r => r.id === id ? { ...r, enabled: !r.enabled } : r);
            scanForRedactions();
            render();
        }

        function toggleOption(key) {
            state.options[key] = !state.options[key];
            render();
        }

        function removeFile(id) {
            state.files = state.files.filter(f => f.id !== id);
            scanForRedactions();
            render();
        }

        function clearAll() {
            state.files = [];
            state.matches = [];
            state.areas = [];
            render();
        }

        function addCustomRule() {
            const nameInput = document.getElementById('custom-rule-name');
            const patternInput = document.getElementById('custom-rule-pattern');
            if (!nameInput || !patternInput) return;

            const name = nameInput.value.trim();
            const pattern = patternInput.value.trim();
            if (!name || !pattern) return;

            // Validate regex
            try {
                new RegExp(pattern);
            } catch (e) {
                alert(`Invalid regex pattern: ${e.message}`);
                return;
            }

            const colors = ['#06b6d4', '#ec4899', '#14b8a6', '#f97316', '#6366f1', '#84cc16'];
            state.rules.push({
                id: generateId(),
                name,
                pattern,
                enabled: true,
                color: colors[state.rules.length % colors.length],
            });

            scanForRedactions();
            render();
        }

        function removeRule(id) {
            state.rules = state.rules.filter(r => r.id !== id);
            scanForRedactions();
            render();
        }

        // --- RENDER ---
        const renderHeader = () => `
            <header class="bg-white border-b border-slate-200 sticky top-0 z-10">
                <div class="max-w-7xl mx-auto px-4 py-4">
                    <div class="flex items-center gap-3">
                        <div class="bg-gradient-to-br from-blue-600 to-indigo-600 p-2 rounded-xl text-white">
                            ${icons.shield}
                        </div>
                        <div>
                            <h1 class="text-xl font-bold text-slate-800">Redaction & Merger Tool</h1>
                            <p class="text-xs text-slate-500">Secure PDF Redaction & Merge Tool</p>
                        </div>
                    </div>
                </div>
            </header>
        `;

        const renderDropZone = () => `
            <div class="space-y-4">
                <div id="dropZone" class="rounded-xl border-2 border-dashed border-slate-300 p-8 text-center hover:border-blue-400 hover:bg-blue-50/50 transition-colors cursor-pointer">
                    <div class="w-12 h-12 mx-auto mb-4 text-slate-400 pointer-events-none">${icons.upload}</div>
                    <p class="text-slate-600 font-medium pointer-events-none">Drag & drop PDF files here</p>
                    <p class="text-slate-400 text-sm mt-1 pointer-events-none">or click to browse</p>
                    <input type="file" id="fileInput" class="hidden" accept=".pdf" multiple onchange="handleFilesAdded(this.files); this.value=''">
                </div>

                ${state.isScanning ? `
                    <div class="flex items-center gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                        <div class="spinner"></div>
                        <span class="text-sm text-blue-700">Extracting text and scanning for sensitive data...</span>
                    </div>
                ` : ''}

                ${state.files.length > 0 ? `
                    <div class="space-y-2">
                        <h3 class="text-sm font-medium text-slate-700">Uploaded Files (${state.files.length})</h3>
                        ${state.files.map(file => `
                            <div class="flex items-center justify-between bg-white border border-slate-200 rounded-lg p-3 hover:shadow-sm transition-shadow">
                                <div class="flex items-center gap-3">
                                    <div class="w-8 h-8 text-blue-500">${icons.fileText}</div>
                                    <div>
                                        <p class="font-medium text-slate-800 text-sm">${file.name}</p>
                                        <p class="text-xs text-slate-500">${file.pageCount} page${file.pageCount !== 1 ? 's' : ''} &bull; ${formatFileSize(file.size)}</p>
                                    </div>
                                </div>
                                <button onclick="removeFile('${file.id}')" class="p-2 hover:bg-red-50 rounded-lg transition-colors">
                                    ${icons.x}
                                </button>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            </div>
        `;

        const renderOptions = () => `
            <div class="flex items-center justify-between p-3 bg-slate-50 rounded-lg">
                <div>
                    <p class="font-medium text-slate-800 text-sm">Remove Metadata</p>
                    <p class="text-xs text-slate-500">Strip author, creation date, etc.</p>
                </div>
                <button onclick="toggleOption('removeMetadata')" class="w-10 h-6 ${state.options.removeMetadata ? 'bg-emerald-500' : 'bg-slate-300'} rounded-full relative cursor-pointer transition-colors">
                    <div class="absolute top-1 w-4 h-4 bg-white rounded-full transition-all ${state.options.removeMetadata ? 'right-1' : 'left-1'}"></div>
                </button>
            </div>
            <div class="flex items-center justify-between p-3 bg-slate-50 rounded-lg">
                <div>
                    <p class="font-medium text-slate-800 text-sm">Compress Output</p>
                    <p class="text-xs text-slate-500">Reduce file size after redaction</p>
                </div>
                <button onclick="toggleOption('compress')" class="w-10 h-6 ${state.options.compress ? 'bg-emerald-500' : 'bg-slate-300'} rounded-full relative cursor-pointer transition-colors">
                    <div class="absolute top-1 w-4 h-4 bg-white rounded-full transition-all ${state.options.compress ? 'right-1' : 'left-1'}"></div>
                </button>
            </div>
            <div class="flex items-center justify-between p-3 bg-slate-50 rounded-lg">
                <div>
                    <p class="font-medium text-slate-800 text-sm">Merge All PDFs</p>
                    <p class="text-xs text-slate-500">Combine into single document</p>
                </div>
                <button onclick="toggleOption('mergeAll')" class="w-10 h-6 ${state.options.mergeAll ? 'bg-emerald-500' : 'bg-slate-300'} rounded-full relative cursor-pointer transition-colors">
                    <div class="absolute top-1 w-4 h-4 bg-white rounded-full transition-all ${state.options.mergeAll ? 'right-1' : 'left-1'}"></div>
                </button>
            </div>
        `;

        const renderRules = () => `
            <div class="space-y-2">
                ${state.rules.map(rule => `
                    <div class="flex items-center justify-between p-3 bg-slate-50 rounded-lg border border-slate-100">
                        <div class="flex items-center gap-3">
                            <button onclick="toggleRule('${rule.id}')" class="w-5 h-5 rounded border flex items-center justify-center transition-colors ${rule.enabled ? 'bg-emerald-500 border-emerald-500' : 'bg-white border-slate-300'}">
                                ${rule.enabled ? `<span class="w-3 h-3 text-white">${icons.check}</span>` : ''}
                            </button>
                            <div class="w-3 h-3 rounded-full" style="background-color: ${rule.color}"></div>
                            <div>
                                <p class="text-sm font-medium text-slate-800">${rule.name}</p>
                                <p class="text-xs text-slate-500 font-mono">${rule.pattern}</p>
                            </div>
                        </div>
                        <button onclick="removeRule('${rule.id}')" class="p-2 hover:bg-red-50 rounded-lg transition-colors">
                            <span class="w-4 h-4 text-red-500">${icons.trash}</span>
                        </button>
                    </div>
                `).join('')}
            </div>
            <div class="border-t border-slate-200 pt-4 mt-4">
                <p class="text-sm font-medium text-slate-700 mb-3">Add Custom Rule</p>
                <div class="space-y-3">
                    <div>
                        <label class="text-xs font-medium text-slate-600">Rule Name</label>
                        <input id="custom-rule-name" class="w-full mt-1 px-3 py-2 border border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none" placeholder="e.g., Phone Number">
                    </div>
                    <div>
                        <label class="text-xs font-medium text-slate-600">Regex Pattern</label>
                        <input id="custom-rule-pattern" class="w-full mt-1 px-3 py-2 border border-slate-300 rounded-lg text-sm font-mono focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none" placeholder="e.g., \\d{10}">
                    </div>
                    <button onclick="addCustomRule()" class="w-full bg-slate-800 hover:bg-slate-900 text-white text-sm font-medium py-2 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                        + Add Rule
                    </button>
                </div>
            </div>
        `;

        const renderReport = () => {
            if (state.files.length === 0) return `<p class="text-sm text-slate-500 italic">Upload PDFs to scan for sensitive data.</p>`;
            if (state.matches.length === 0) return `<p class="text-sm text-emerald-600 font-medium">No sensitive data detected.</p>`;

            const grouped = state.matches.reduce((acc, match) => {
                if (!acc[match.ruleName]) acc[match.ruleName] = { items: [], color: match.color };
                acc[match.ruleName].items.push(match);
                return acc;
            }, {});

            return Object.entries(grouped).map(([ruleName, data]) => `
                <div class="bg-amber-50 border border-amber-200 rounded-lg p-3 mb-2">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm font-medium text-amber-800">${ruleName}</span>
                        <span class="text-xs bg-amber-200 text-amber-800 px-2 py-0.5 rounded-full">${data.items.length} found</span>
                    </div>
                    <div class="flex flex-wrap gap-1 overflow-hidden w-full">
                        ${[...new Set(data.items.map(i => i.text))].slice(0, 5).map(text => `
                            <span class="text-xs bg-white border border-amber-300 px-2 py-1 rounded font-mono text-slate-600 max-w-full overflow-hidden text-ellipsis whitespace-nowrap inline-block">${text}</span>
                        `).join('')}
                        ${data.items.length > 5 ? `<span class="text-xs text-amber-700 px-2 py-1">+${data.items.length - 5} more</span>` : ''}
                    </div>
                </div>
            `).join('');
        };

        const renderPreview = () => {
            const totalSize = state.files.reduce((acc, f) => acc + f.size, 0);
            const totalPages = state.files.reduce((acc, f) => acc + f.pageCount, 0);

            if (state.files.length === 0) {
                return `
                    <div class="text-center py-12 bg-slate-50 rounded-xl border-2 border-dashed border-slate-200">
                        <div class="w-16 h-16 mx-auto mb-4 text-slate-300">${icons.fileText}</div>
                        <p class="text-slate-500">No PDFs uploaded yet</p>
                    </div>
                `;
            }

            return `
                <div class="grid grid-cols-2 gap-4 mb-4">
                    ${state.files.map(file => {
                        const fileAreas = state.areas.filter(a => a.fileId === file.id);
                        return `
                            <div class="bg-white border border-slate-200 rounded-xl overflow-hidden hover:shadow-md transition-shadow relative group">
                                <div class="aspect-[3/4] bg-slate-100 relative">
                                    <div class="w-12 h-12 text-slate-400 absolute inset-0 m-auto">${icons.fileText}</div>
                                    ${fileAreas.map(area => `
                                        <div class="absolute bg-black/90 flex items-center justify-center"
                                             style="left: ${area.x}%; top: ${area.y}%; width: ${Math.max(area.width, 2)}%; height: ${Math.max(area.height, 1.5)}%;">
                                        </div>
                                    `).join('')}
                                </div>
                                <div class="p-3">
                                    <p class="font-medium text-slate-800 text-sm truncate">${file.name}</p>
                                    <div class="flex items-center justify-between mt-1">
                                        <p class="text-xs text-slate-500">${file.pageCount} page${file.pageCount !== 1 ? 's' : ''}</p>
                                        ${fileAreas.length > 0 ? `<span class="text-xs bg-red-100 text-red-700 px-2 py-0.5 rounded-full">${fileAreas.length} redacted</span>` : ''}
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>

                <div class="bg-blue-50 border border-blue-200 rounded-xl p-4 mb-4">
                    <div class="grid grid-cols-3 gap-4 text-center">
                        <div>
                            <p class="text-2xl font-bold text-blue-700">${state.files.length}</p>
                            <p class="text-xs text-blue-600">Files</p>
                        </div>
                        <div>
                            <p class="text-2xl font-bold text-blue-700">${totalPages}</p>
                            <p class="text-xs text-blue-600">Total Pages</p>
                        </div>
                        <div>
                            <p class="text-2xl font-bold text-blue-700">${formatFileSize(totalSize)}</p>
                            <p class="text-xs text-blue-600">Size</p>
                        </div>
                    </div>
                </div>

                <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-3 text-xs text-emerald-800 mb-4">
                    <p class="font-medium mb-1">Redaction Details:</p>
                    <ul class="list-disc list-inside space-y-1">
                        <li>${state.matches.length} sensitive item${state.matches.length !== 1 ? 's' : ''} will be redacted with black rectangles</li>
                        ${state.options.removeMetadata ? '<li>Document metadata will be stripped</li>' : ''}
                        ${state.options.mergeAll && state.files.length > 1 ? `<li>${state.files.length} files will be merged into one</li>` : ''}
                    </ul>
                </div>

                <button onclick="handleDownload()" ${state.isProcessing ? 'disabled' : ''}
                    class="w-full bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white font-semibold h-11 rounded-lg px-8 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed transition-all">
                    ${state.isProcessing ? `<div class="spinner mr-2" style="border-top-color: white; border-color: rgba(255,255,255,0.3)"></div> Processing...` : `<span class="w-5 h-5 mr-2">${icons.download}</span> ${state.options.mergeAll && state.files.length > 1 ? 'Download Merged & Redacted PDF' : 'Download Redacted PDF'}`}
                </button>
            `;
        };

        function render() {
            const app = document.getElementById('app');
            app.innerHTML = `
                ${renderHeader()}
                <main class="max-w-7xl mx-auto px-4 py-8 flex-grow">
                    <div class="grid lg:grid-cols-3 gap-6">
                        <div class="lg:col-span-2 space-y-6">
                            <div class="rounded-xl border bg-white text-card-foreground shadow">
                                <div class="flex flex-col space-y-1.5 p-6">
                                    <h3 class="font-semibold leading-none tracking-tight flex items-center gap-2">
                                        <span class="w-5 h-5 text-blue-600">${icons.fileText}</span>
                                        Upload PDFs
                                    </h3>
                                    <p class="text-sm text-muted-foreground">Drag and drop PDF files to begin redaction</p>
                                </div>
                                <div class="p-6 pt-0">${renderDropZone()}</div>
                            </div>

                            <div class="rounded-xl border bg-white text-card-foreground shadow">
                                <div class="flex flex-col space-y-1.5 p-6">
                                    <h3 class="font-semibold leading-none tracking-tight flex items-center gap-2">
                                        <span class="w-5 h-5 text-purple-600">${icons.settings}</span>
                                        Processing Options
                                    </h3>
                                </div>
                                <div class="p-6 pt-0 space-y-4">${renderOptions()}</div>
                            </div>
                        </div>

                        <div class="space-y-6">
                            <div class="rounded-xl border bg-white text-card-foreground shadow">
                                <div class="flex flex-col space-y-1.5 p-6">
                                    <h3 class="font-semibold leading-none tracking-tight">Redaction Rules</h3>
                                    <p class="text-sm text-muted-foreground">Configure patterns to auto-redact</p>
                                </div>
                                <div class="p-6 pt-0">${renderRules()}</div>
                            </div>

                            <div class="rounded-xl border bg-white text-card-foreground shadow">
                                <div class="flex flex-col space-y-1.5 p-6">
                                    <h3 class="font-semibold leading-none tracking-tight">Scan Results</h3>
                                    <p class="text-sm text-muted-foreground">Detected sensitive data</p>
                                </div>
                                <div class="p-6 pt-0">${renderReport()}</div>
                            </div>

                            <div class="rounded-xl border bg-white text-card-foreground shadow">
                                <div class="flex flex-col space-y-1.5 p-6">
                                    <div class="flex items-center justify-between">
                                        <h3 class="font-semibold leading-none tracking-tight">Preview & Export</h3>
                                        ${state.files.length > 0 ? `
                                            <button onclick="clearAll()" class="text-xs text-red-600 hover:text-red-700 flex items-center gap-1">
                                                <span class="w-4 h-4">${icons.trash}</span> Clear All
                                            </button>
                                        ` : ''}
                                    </div>
                                </div>
                                <div class="p-6 pt-0">${renderPreview()}</div>
                            </div>
                        </div>
                    </div>
                </main>
                <footer class="bg-white border-t border-slate-200 mt-12">
                    <div class="max-w-7xl mx-auto px-4 py-6 text-center text-sm text-slate-500">
                        <p>AI Batch Stars &mdash; PDF Redaction & Merge Tool</p>
                    </div>
                </footer>
            `;
        }

        // --- INIT ---
        render();

        // Setup drag and drop using event delegation (survives re-renders)
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            const dropZone = document.getElementById('dropZone');
            if (dropZone && (e.target === dropZone || dropZone.contains(e.target))) {
                dropZone.classList.add('border-blue-500', 'bg-blue-50');
            }
        });
        document.addEventListener('dragleave', (e) => {
            const dropZone = document.getElementById('dropZone');
            if (dropZone && !dropZone.contains(e.relatedTarget)) {
                dropZone.classList.remove('border-blue-500', 'bg-blue-50');
            }
        });
        document.addEventListener('drop', (e) => {
            e.preventDefault();
            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.remove('border-blue-500', 'bg-blue-50');
                if (e.target === dropZone || dropZone.contains(e.target)) {
                    handleFilesAdded(e.dataTransfer.files);
                }
            }
        });
        document.addEventListener('click', (e) => {
            const dropZone = document.getElementById('dropZone');
            if (dropZone && (e.target === dropZone || dropZone.contains(e.target))) {
                const fileInput = document.getElementById('fileInput');
                if (e.target !== fileInput) fileInput.click();
            }
        });
    </script>
</body>
</html>